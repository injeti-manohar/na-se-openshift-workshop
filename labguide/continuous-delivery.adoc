##  Automating Deployments Using Pipelines

In this lab you will learn about deployment pipelines and you will create a pipeline to
automate build and deployment of the gateway service.

#### Continuous Delivery
So far you have been building and deploying each service manually to OpenShift. Although
it's convenient for local development, it's an error-prone way of delivering software if
extended to test and production environments.

Continuous Delivery (CD) refers to a set of practices with the intention of automating
various aspects of delivery software. One of these practices is called delivery pipeline
which is an automated process to define the steps a change in code or configuration has
to go through in order to reach upper environments and eventually to production.

OpenShift simplifies building CI/CD Pipelines by integrating
the popular https://jenkins.io/doc/book/pipeline/overview/[Jenkins pipelines] into
the platform and enables defining truly complex workflows directly from within OpenShift.

#### Define the Deployment Pipeline

OpenShift has built-in support for CI/CD pipelines by allowing developers to define
a https://jenkins.io/solutions/pipeline/[Jenkins pipeline] for execution by a Jenkins
automation engine, which is automatically provisioned on-demand by OpenShift when needed.

The build can get started, monitored, and managed by OpenShift in
the same way as any other build types e.g. S2I. Pipeline workflows are defined in
a Jenkinsfile, either embedded directly in the build configuration, or supplied in
a Git repository and referenced by the build configuration.

Jenkinsfile is a text file that contains the definition of a Jenkins Pipeline
and is created using a https://jenkins.io/doc/book/pipeline/syntax/[scripted or declarative syntax].

Create a file called `Jenkinsfile` in the root of the project directory:

[source, bash]
----
cat <<EOF > Jenkinsfile
pipeline {
  agent {
      label 'maven'
  }
  stages {
    stage('Build Image') {
      steps {
        script {
          openshift.withCluster() {
            def bc = openshift.startBuild("gateway")
            bc.logs('-f')
          }
        }
      }
    }
    stage('Deploy') {
      steps {
        script {
          openshift.withCluster() {
            def dc = openshift.selector("dc", "gateway")
            dc.rollout().latest()
            dc.rollout().status()
          }
        }
      }
    }
  }
}
EOF
----

This pipeline has three stages:

* *Build JAR*: to build and test the jar file using Maven
* *Build Image*: to build a container image from the gateway JAR archive using OpenShift S2I
* *Deploy*: to deploy the gateway container image in the current project

Note that the pipeline definition is fully integrated with OpenShift and you can
perform operations like image build, image deploy, etc directly from within the `Jenkinsfile`.

When building deployment pipelines, it's important to treat your https://martinfowler.com/bliki/InfrastructureAsCode.html[infrastructure and everything else that needs to be configured (including the pipeline definition) as code]
and store them in a source repository for version control.

Commit and push the `Jenkinsfile` to the Git repository.

[source, bash]
----
git add Jenkinsfile
git commit -m "pipeline added"
git push origin master
----

The pipeline definition is ready and now you can create a deployment pipeline using
this `Jenkinsfile`.

#### Create an OpenShift Pipeline

Like mentioned, {{OPENSHIFT_DOCS_BASE}}/architecture/core_concepts/builds_and_image_streams.html#pipeline-build[OpenShift Pipelines]
enable creating deployment pipelines using the widely popular `Jenkinsfile` format.

OpenShift automates deployments using {{OPENSHIFT_DOCS_BASE}}/dev_guide/deployments/basic_deployment_operations.html#triggers[deployment triggers]
that react to changes to the container image or configuration. Since you want to control the deployments instead
from the pipeline, you should remove the gateway deploy triggers so that building a new
gateway container image wouldn't automatically result in a new deployment. That would
allow the pipeline to decide when a deployment should occur.

Remove the gateway deployment triggers:

[source, bash]
----
oc set triggers dc/gateway --manual
----

Deploy a Jenkins server using the provided template and container image that
comes out-of-the-box with OpenShift:

[source, bash]
----
oc new-app jenkins-ephemeral
----

After Jenkins is deployed and is running (verify in web console), then create a
deployment pipeline by running the following command:

[source, bash]
----
oc new-app . --name=gateway-pipeline --strategy=pipeline
----

The above command creates a new build config of type pipeline which is automatically
configured to fetch the `Jenkinsfile` from the Git repository of the current folder
and execute it on Jenkins.

Go OpenShift Web Console inside the **{{COOLSTORE_PROJECT}}** project and from the left sidebar
click on **Builds >> Pipelines**

image::cd-pipeline-inprogress.png[]

Pipeline syntax allows creating complex deployment scenarios with the possibility of defining
checkpoint for manual interaction and approval process using
https://jenkins.io/doc/pipeline/steps/[the large set of steps and plugins that Jenkins provide] in
order to adapt the pipeline to the process used in your team. You can see a few examples of
advanced pipelines in the
https://github.com/openshift/origin/tree/master/examples/jenkins/pipeline[OpenShift GitHub Repository].

In order to update the deployment pipeline, all you need to do is to update the `Jenkinsfile`
in the `cloud-native-labs` Git repository, which we will do in the next lab.
OpenShift pipeline automatically executes the updated pipeline next time it runs.

Well done! You are ready for the next lab.
