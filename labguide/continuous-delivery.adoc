##  Automating Deployments Using Pipelines

In this lab you will learn about deployment pipelines and you will create a pipeline to
automate build and deployment of the gateway service.

#### Continuous Delivery
So far you have been building and deploying each service manually to OpenShift. Although
it's convenient for local development, it's an error-prone way of delivering software if
extended to test and production environments.

Continuous Delivery (CD) refers to a set of practices with the intention of automating
various aspects of delivery software. One of these practices is called delivery pipeline
which is an automated process to define the steps a change in code or configuration has
to go through in order to reach upper environments and eventually to production.

OpenShift simplifies building CI/CD Pipelines by integrating
the popular https://jenkins.io/doc/book/pipeline/overview/[Jenkins pipelines] into
the platform and enables defining truly complex workflows directly from within OpenShift.

#### Define the Deployment Pipeline

OpenShift has built-in support for CI/CD pipelines by allowing developers to define
a https://jenkins.io/solutions/pipeline/[Jenkins pipeline] for execution by a Jenkins
automation engine, which is automatically provisioned on-demand by OpenShift when needed.

The build can get started, monitored, and managed by OpenShift in
the same way as any other build types e.g. S2I. Pipeline workflows are defined in
a Jenkinsfile, either embedded directly in the build configuration, or supplied in
a Git repository and referenced by the build configuration.

Jenkinsfile is a text file that contains the definition of a Jenkins Pipeline
and is created using a https://jenkins.io/doc/book/pipeline/syntax/[scripted or declarative syntax].

Create a file called `Jenkinsfile` in the root of the project directory:

[source, bash]
----
cat <<EOF > Jenkinsfile
pipeline {
  agent {
      label 'maven'
  }
  stages {
    stage('Build Image') {
      steps {
        script {
          openshift.withCluster() {
            def bc = openshift.startBuild("gateway")
            bc.logs('-f')
          }
        }
      }
    }
    stage('Deploy') {
      steps {
        script {
          openshift.withCluster() {
            def dc = openshift.selector("dc", "gateway")
            dc.rollout().latest()
            dc.rollout().status()
          }
        }
      }
    }
  }
}
EOF
----

This pipeline has three stages:

* *Build JAR*: to build and test the jar file using Maven
* *Build Image*: to build a container image from the gateway JAR archive using OpenShift S2I
* *Deploy*: to deploy the gateway container image in the current project

Note that the pipeline definition is fully integrated with OpenShift and you can
perform operations like image build, image deploy, etc directly from within the `Jenkinsfile`.

When building deployment pipelines, it's important to treat your https://martinfowler.com/bliki/InfrastructureAsCode.html[infrastructure and everything else that needs to be configured (including the pipeline definition) as code]
and store them in a source repository for version control.

Commit and push the `Jenkinsfile` to the Git repository.

[source, bash]
----
git add Jenkinsfile
git commit -m "pipeline added"
git push origin master
----

The pipeline definition is ready and now you can create a deployment pipeline using
this `Jenkinsfile`.

#### Create an OpenShift Pipeline

Like mentioned, {{OPENSHIFT_DOCS_BASE}}/architecture/core_concepts/builds_and_image_streams.html#pipeline-build[OpenShift Pipelines]
enable creating deployment pipelines using the widely popular `Jenkinsfile` format.

OpenShift automates deployments using {{OPENSHIFT_DOCS_BASE}}/dev_guide/deployments/basic_deployment_operations.html#triggers[deployment triggers]
that react to changes to the container image or configuration. Since you want to control the deployments instead
from the pipeline, you should remove the gateway deploy triggers so that building a new
gateway container image wouldn't automatically result in a new deployment. That would
allow the pipeline to decide when a deployment should occur.

Remove the gateway deployment triggers:

[source, bash]
----
oc set triggers dc/gateway --manual
----

Deploy a Jenkins server using the provided template and container image that
comes out-of-the-box with OpenShift:

[source, bash]
----
oc new-app jenkins-ephemeral
----

After Jenkins is deployed and is running (verify in web console), then create a
deployment pipeline by running the following command:

[source, bash]
----
oc new-app . --name=gateway-pipeline --strategy=pipeline
----

The above command creates a new build config of type pipeline which is automatically
configured to fetch the `Jenkinsfile` from the Git repository of the current folder
(`gateway-wildfly-swarm` Git repository) and execute it on Jenkins.

Go OpenShift Web Console inside the **{{COOLSTORE_PROJECT}}** project and from the left sidebar
click on **Builds >> Pipelines**

image::cd-pipeline-inprogress.png[]

Pipeline syntax allows creating complex deployment scenarios with the possibility of defining
checkpoint for manual interaction and approval process using
https://jenkins.io/doc/pipeline/steps/[the large set of steps and plugins that Jenkins provide] in
order to adapt the pipeline to the process used in your team. You can see a few examples of
advanced pipelines in the
https://github.com/openshift/origin/tree/master/examples/jenkins/pipeline[OpenShift GitHub Repository].

In order to update the deployment pipeline, all you need to do is to update the `Jenkinsfile`
in the `gateway-wildfly-swarm` Git repository. OpenShift pipeline automatically executes the
updated pipeline next time it runs.

#### Run the Pipeline on Every Code Change

Manually triggering the deployment pipeline to run is useful but the real goal
is to be able to build and deploy every change in code or configuration at least
to lower environments (e.g. dev and test) and ideally all the way to production
with some manual approvals in-place.

In order to automate triggering the pipeline, you can define a webhook on your
Git repository to notify OpenShift on every commit that is made to the Git
repository and trigger a pipeline execution.

You can get see the webhook links in the OpenShift Web Console by going to
**Build >> Pipelines**, clicking on the pipeline and going to the
**Configurations** tab.

{% if MINISHIFT == true %}

Copy the Generic webhook url which you will need in the next steps.

Go to Gogs and your **gateway-wildfly-swarm** Git repository, then click on **Settings**.

image::cd-gogs-settings-link.png[]

On the left menu, click on **Webhooks** and then on **Add Webhook** button and then **Gogs**.

Create a webhook with the following details:

* **Payload URL**: paste the Generic webhook url you copied from the `gateway-pipeline`
* **Content type**: `application/json`

Click on **Add Webhook**.

image::cd-gogs-webhook-add.png[]

All done. You can click on the newly defined webhook to see the list of *Recent Delivery*.
Clicking on the **Test Delivery** button allows you to manually trigger the webhook for
testing purposes. Click on it and verify that the `gateway-pipeline` start running
immediately.

{% else %}

Copy the GitHub webhook url which you will need in the next steps.

Go to GitHub and your **gateway-wildfly-swarm** Git repository, then click on **Settings**.

image::cd-github-settings-link.png[]

On the left menu, click on **Webhooks** and then on **Add webhook** button. Enter your password
once more if you are ask to do so.

Create a webhook with the following details:

* **Payload URL**: paste the GitHub webhook url you copied from the `gateway-pipeline`
* **Content type**: `application/json`
* Disable SSL by clicking on *Disable SSL verification*.

The reason for disabling SSL in this lab is that we are using self-generated certificates
in this lab environment which cannot be verified by GitHub.

[NOTE]
====
When adding a webhook to GitHub, your OpenShift cluster should be accessible to the
public internet in order for GitHub to be able to invoke the provided webhook url.

If you are not sure, enter your OpenShift Web Console url on https://isitup.org[Is It Up?]
and you'll know!
====
Click on **Add webhook**

image::cd-github-webhook-add.png[]

All done. You can click on the newly defined webhook to see the list of **Recent Delivery**.
Clicking on a delivery, allows you to manually trigger the webhook for testing purposes by
clicking on the **Redeliver** button.

{% endif %}

Well done! You are ready for the next lab.
